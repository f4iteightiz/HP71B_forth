       FORTH
****************************************************************
*                           HEADER
*
* under BY NC SA CreativeCommons 4.0
* https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en
* pascaldagornet@yahoo.de
****************************************************************
*
* columns..
* 1:label  8:mnemonic  15:modifier  from 24:comments
*
* System entry points: see 14-1 of IMS Vol 1
=UMODES EQU #0BDB1           set the modes
=SUBONE EQU #0C327           substract 1 to (A,B) page 1392 of idsv3
=ADDONE EQU #0C330           add 1 to (A,B) (AD15S..) pdf page 1391 idsv3
=IN2-15 EQU #0C33E           1/X where X=(A,B)
=X/Y15  EQU #0C34F           X/Y where X=(A,B) and Y=(C,D)
=AD2-12 EQU #0C35F           12 digit add = (A) + (C) 15dig result in (A,B) idsv3 pdf page 1394
=AD2-15 EQU #0C363           15-digit add = (A,B) + (C,D) idsv3 pdf page 1394
=AD15S  EQU #0C369           same + SB reset pdf page 1394 of idsv3
=MP2-12 EQU #0C432           12 digit * (A) * (C) result 15dig in (A,B) idsv3 pdf page 1397
=MP1-12 EQU #0C436           12 digit * (A,B) * (C) result 15dig in (A,B) idsv3 pdf page 1397
=MP2-15 EQU #0C43A           15-digit multiply (A,B) * (C,D) result 15dig in (A,B) idsv3 pdf page 1397
=DV2-12 EQU #0C4A8           12-digit divise (A) and (C) result in (A,B) idsv3 pdf page 1399
=DV2-15 EQU #0C4AC           15-digit divise (A,B) and (C,d) result in (A,B) idsv3 pdf page 1399
=SQR15  EQU #0C534           idsv3 pdf page 1401 SQR(A,B) result in (A,B)
=XYEX   EQU #0C697           Exchange (A,B) with (C,D)  pdf idsv3 page 1408
=SPLITA EQU #0C6BF           Extend (A) into (A,B) pdf idsv3 page 1408
=CLRFRC EQU #0C6F4           (A,B) to (A,B) w/o fractio part page 1409 exit in DECMODE carry set if no frac part
=FRAC15 EQU #0C70E           frac of (A,B) into (A,B) page 1411 pdf ids3
=SPLTAC EQU #0C934           Extend (A) and (C) into (A,B) and (C,D) pdf idsv3 page 1424
=SPLITC EQU #0C940           Extend (C) into (C,D) pdf idsv3 page 1425
=uRES12 EQU #0C994           Reduce (A,B) into (C) idsv3 pdf page 1426 uses R3 therefore avoid it
=YX2-12 EQU #0D274           Y^X & Reg 0 2 3 modified
=STAB1  EQU #0D3D9           Store AB into scratch1 (R0,R1) pdf idsv3 page 1471
=EXAB1  EQU #0D3E7           Exchange AB and scratch1 pdf idsv3 page 1471
=RCCD1  EQU #0D3F1           Recall scratch1 into CD pdf idsv3 page 1471
=STAB2  EQU #0D400           Store AB into scratch2 (R2,R3) pdf idsv3 page 1471
=EXAB2  EQU #0D40E           Exchange AB and scratch2 pdf idsv3 page 1471
=RCCD2  EQU #0D41C           Recall scratch2 into CD pdf idsv3 page 1471
=STCD2  EQU #0D427           Store CD into scratch2 (R2,R3) pdf idsv3 page 1471
=SPLTA  EQU #0D706           = splita ids v3 page 1500
=SPLTB  EQU #0D70C           = splitb ids v3 page 1500
=SIN12  EQU #0D716           = splita ids v3 page 1502
=SIN15  EQU #0D71A           ids v3 page 1502 alter R0 R1
=COS12  EQU #0D721           = splita ids v3 page 1502
=COS15  EQU #0D725           ids v3 page 1502 alter R0 R1
=PI/2   EQU #0DB77           load PI/2 into (C,D) idsv3 pdf page 1517
=ATAN15 EQU #0DBBE           atan of 15 digit args (A,B) result in (A,B) ids v3 page 1520
=uRESD1 EQU #0E1EE           Reduce (A,B) into (C), similar uRES12, exi: R3 touched, S8-11 ..
*                            dont alter D1,P=14 ids3 pdf page 1553
* =FNRTN4 EQU #0F238          function return, page 1679 ONLY FOR BASIC
=SPLTAX EQU #0E62B           SETDEC, Extend (A) into (A,B) Page 1585
=BP     EQU #0EADF           make beep float A HZ Float C duration sec
=HDFLT  EQU #1B31B           change hex integ A(A) to 12dig float in A(W) exit DEC mode
=FLOAT  EQU #1B322           change integ to 12dig float in A page 2631 ids pdf vol3
=FLTDH  EQU #1B223           Convert 12digit flt A to 5 digit Hex Integ A(A) pdf 2627 idsv3, see 
*                             out with hex mode, see FTOI forth/asm ids page pdf 308
=OL     EQU #2FBC0           L address
=OX     EQU #2FBD0           X address
=OY     EQU #2FBE0           Y address
=OZ     EQU #2FBF0           Z address
=OT     EQU #2FC00           T address
*
* FORTH entry points:
=FEND   EQU #E08E9           PUTABX,GETFP
=CHS    EQU #E1518           change X sign; dont change LastX
=NUMST  EQU #E1718           GET X INTO (A,B); L = X
=MOD    EQU #E1CA1           modulo ids Forth/ASM pdf page 287
=ABS    EQU #E1A23           (n -- |n|)
=XXYY   EQU #E212D           comparison of a(X?) and c(Y?) (or zero) pdf page 304 Forth/asm ids, out with GETFP
=CMPST  EQU #E216C           comparison operator routine pdf page 304 Forth/asm ids, out with SAVEFP
=X<>Y   EQU #E23A5           X<>Y pdf page 313 Forth/asm
=OVER   EQU #E2538           (n1 n2 -- n1 n2 n1)
=SAVEFP EQU #E717A           save Forth pointer
=GETFP  EQU #E71A5           restore Forth pointers
=GETX   EQU #E728A           Put X into (A,B) 
=GETX+L EQU #E72DF           Put X into (A,B) and X in L
=PUTABX EQU #E72F5           Put (A,B) into X, .. uRES12 GETFP pdf page 609 Forth/asm ids
=STKLFT EQU #E7320           Stacklift Forth OM page 609 pdf
*
* general remarks:
*   uRES12 MODES GETX+L using D1 therefore D1 has to be saved before its use
*   SETDEC has to be used before most of math functions
*   ADDONE and SUBONE has a warning message WRN; workaround so far not found
*   SAVEFP and GETFP: check where really necessary for optimizing code
*   X<>L and others could be deleted because it is the same like L X<>
*     or use L X <F>
*   GOSBVL NUMST is making issues with GETX+L where sign is checked. Avoid sometimes.
*   A label cannot start with 0 or 1 or.. 9 letters
*   the entries can have = in the front of them or not ( = is ignored)
*   freeze if D1 wildly changed in a word
*   P=     0 before LC(5)  =OY ! or X Z..
*   C then A has to be loaded prior any AD MP DIV
****************************************************************
*                           WORDS
****************************************************************
*
*
****************************************************************
* CLFV : initialize float variable to zero.
* FVAR1 CLFV .. will put 0 into the FVARIABLE FVAR1
* tested 18 Sept 2024
       WORD 'CLFV'
       GOSBVL =SAVEFP        save pointers: CPU reg, D0, D1
       C=DAT1 A              copy data at address in D1 into C(A)
       CD0EX                 exchange C(A) with D0 (the instruction pointer)
       A=0    W
       DAT0=A W
       GOSBVL =GETFP         restore Forth pointers
       D1=D1+ 5
       RTNCC
****************************************************************
*
*
****************************************************************
* CLX : set X to zero. LastX not modified (see HP41).
* tested 18 Sept 2024
       WORD 'CLX'
       GOSBVL =SAVEFP
       P=     0
       LC(5)  =OX            put X-address into field A of register C low order 5 nibbles
       CD0EX                 exchange data pointer address D0 with C(A)
       A=0    W
       DAT0=A W
       GOSBVL =GETFP         restore Forth pointers
       RTNCC
****************************************************************
*
*
****************************************************************
* CLST : set X Y Z T to zero. LastX not modified (see HP41).
* testes 02 Aug 2024
       WORD 'CLST'
       GOSBVL =SAVEFP
       P=     0
       LC(5)  =OX
       CD0EX
       A=0    W
       DAT0=A W              X set to zero
       D0=D0+ 16
       DAT0=A W              Y set to zero
       D0=D0+ 16
       DAT0=A W              Z set to zero
       D0=D0+ 16
       DAT0=A W              T set to zero
       GOSBVL =GETFP         restore Forth pointers
       RTNCC
****************************************************************
*
*
****************************************************************
* 1TOFV : initialize float variable to 1. tested 26 July 2024
* FVAR1 1TOFV .. will put 1 into the FVARIABLE FVAR1
       WORD '1TOFV'
       C=DAT1 A              copy data at address in D1 into C(A)
       CD0EX                 exchange C(A) with D0 (the instruction pointer)
       A=0    W              clear A
       P=     14
       A=A+1  P              put 1 at P=14 of the variable
       DAT0=A W
       CD0EX                 restore D0 the instruction pointer
       D1=D1+ 5              throw the D1 entry (seen in integer stack) away
       RTNCC
****************************************************************
*
*
****************************************************************
* 1TOX : put 1 into X . no stack move. LastX not modified. tested 17 July 2024
       WORD '1TOX'
       GOSBVL =SAVEFP
       P=     0
       LC(5)  =OX            put X-address into field A of register C low order 5 nibbles
       CD0EX                 exchange data pointer address D0 with C(A)
       A=0    W
       P=     14
       A=A+1  P
       DAT0=A W
       GOSBVL =GETFP         restore Forth pointers
       RTNCC
****************************************************************
*
*
****************************************************************
* X-2 : substract 2 to X ; X transfered to LASTX.
* next: test if 2x SUBONE works 
       WORD 'X-2'
       GOSBVL =NUMST         GET X INTO (A,B), uMODES;SAVEFP;GETX+L
*       GOSBVL =SUBONE        WRN: appear, therefore better next
       C=0    W
       C=-C-1 S              negativ 2in (C,D)
       D=0    W
       P=     14
       D=D+1  P              
       D=D+1  P              2 in mantissa of D 
       GOSBVL =AD2-15
       GOSBVL =PUTABX
       RTNCC
****************************************************************
*
*
****************************************************************
* X-1 : substract 1 to X ; X transfered to LASTX.
* next: test if 1x SUBONE works 
       WORD 'X-1'
       GOSBVL =NUMST         GET X INTO (A,B), uMODES;SAVEFP;GETX+L
*       GOSBVL =SUBONE        WRN: appear, therefore better next
       C=0    W
       C=-C-1 S
       D=0    W
       P=     14
       D=D+1  P              1 in Register D
       GOSBVL AD2-15
       GOSBVL =PUTABX
       RTNCC
****************************************************************
*
*
****************************************************************
* X+1 : add 1 to X ; X transfered to LASTX.
* next: test if 1x ADDONE works 
       WORD 'X+1'
       GOSBVL =NUMST         GET X INTO (A,B), uMODES;SAVEFP;GETX+L
*       GOSBVL =ADDONE        WRN: appear, therefore better next
       C=0    W
       D=0    W
       P=     14
       D=D+1  P              1 in Register B
       GOSBVL =AD2-15
       GOSBVL =PUTABX
       RTNCC
****************************************************************
*
*
****************************************************************
* X+2 : add 2 to X ; X transfered to LASTX. Tested 10 July 2024
* next: test if 2x ADDONE works 
       WORD 'X+2'
       GOSBVL =NUMST         GET X INTO (A,B), uMODES;SAVEFP;GETX+L
       C=0    W
       D=0    W
       P=     14
       D=D+1  P              
       D=D+1  P              2 in mantissa of D
       GOSBVL =AD2-15
       GOSBVL =PUTABX
       RTNCC
****************************************************************
*
*
****************************************************************
* X*2 : multiply X by 2; X transfered to LASTX. Tested 11July2024
       WORD 'X*2'
       GOSBVL =NUMST         GET X INTO (A,B), uMODES;SAVEFP;GETX+L
       C=B    W
       D=C    W
       C=A    W              copy (A,B) to (C,D). use STAB1 and RCCD1
       GOSBVL =AD2-15        (A,B) + (C,D) and put result in (A,B) = X+X = 2*X
       GOSBVL =PUTABX
       RTNCC
****************************************************************
*
*
****************************************************************
* X/2 : divise X by 2; X transfered to LASTX. Tested 10July2024
       WORD 'X/2'
       GOSBVL =NUMST         GET X INTO (A,B), uMODES;SAVEFP;GETX+L
       C=0    W
       D=C    W
       P=     14
       D=D+1  P
       D=D+1  P              2 in Register D
       GOSBVL =DV2-15        (A,B) / (C,D) = and result in (A,B)
       GOSBVL =PUTABX
       RTNCC
****************************************************************
*
*
****************************************************************
* X<> exchange the value in the variable with the value in X
* use: FVAR1 X<>
* tested 15july2024
* use like the word X<=0? the ST flag for all variants below?
       WORD 'X<>'
       P=     0
       LC(5)  =OX            put X-address into C(A)
       CD0EX                 exchange data pointer address D0 with C(A)
       R2=C                  save D0
       A=DAT0 W              A = value of X from its address in C(A)
       R0=A                  R0 = X
       C=DAT1 A              copy data at address in D1 into C(A)
       CD0EX
       A=DAT0 W              copy data at address in D0 (in C(A)) into W in A
       R1=A                  R1 = Reg value
       P=     0
       LC(5)  =OX             put X-address into C(A)
       CD0EX                 exchange data pointer address D0 with C(A)
       A=R1
       DAT0=A W              X has now value of Reg
       C=DAT1 A              copy data at address in D1 into C(A)
       CD0EX                 exchange C(A) with D0
       A=R0
       DAT0=A W              value of X into variable
       C=R2
       D0=C                  restore D0
       D1=D1+ 5              return nothing on data stack
       RTNCC
****************************************************************
*
*
****************************************************************
* X<>Z exchange the HP41 registers, similar to X<>Y. tested 12 July 2024
       WORD 'X<>Z'
       P=     0
       LC(5)  =OX            put X-address into field A of register C low order 5 nibbles
       CD0EX                 put data pointer D0 into C(A)
       R1=C                  save D0 into R1
       C=DAT0 W              C = value of X (which is in D0)
       D0=D0+ 16             D0 has now Y addr
       D0=D0+ 16             D0 has now Z addr
       A=DAT0 W              put value of Z into A via addr in D0
       DAT0=C W              Z = value of X
       D0=D0- 16
       D0=D0- 16             D0 -> X
       DAT0=A W              X = value of Z
       C=R1
       D0=C                  restore D0
       RTNCC
****************************************************************
*
*
****************************************************************
* X<>T exchange the HP41 registers, tested 12 July 2024
       WORD 'X<>T'
       P=     0
       LC(5)  =OX            put X-address into field A of register C low order 5 nibbles
       CD0EX                 put data pointer D0 into C(A)
       R1=C                  save D0 into R1
       C=DAT0 W              C = value of X
       D0=D0+ 16             D0 -> Y
       D0=D0+ 16             D0 -> Z
       D0=D0+ 16             D0--> T
       A=DAT0 W              put value of T into A
       DAT0=C W              T = value of X
       D0=D0- 16
       D0=D0- 16
       D0=D0- 16             D0 -> X
       DAT0=A W              X = value of T
       C=R1
       D0=C                  restore D0
       RTNCC
****************************************************************
*
*
****************************************************************
* X<>L exchange the HP41 registers, tested 12 July 2024
       WORD 'X<>L'
       P=     0
       LC(5)  =OX            put X-address into field A of register C low order 5 nibbles
       CD0EX                 put data pointer D0 into C(A)
       R1=C                  save D0 into R1
       C=DAT0 W              C = value of X
       D0=D0- 16             D0--> L
       A=DAT0 W              put value of L into A
       DAT0=C W              L = value of X
       D0=D0+ 16             D0 -> X
       DAT0=A W              X = value of L
       C=R1
       D0=C                  restore D0(A) from C(A)
       RTNCC
****************************************************************
*
*
****************************************************************
* Y<> exchange the value in the variable with the value in Y
*       use: FVAR1 Y<>
       WORD 'Y<>'
       P=     0
       LC(5)  =OY
       CD0EX
       R2=C
       A=DAT0 W
       R0=A
       C=DAT1 A
       CD0EX
       A=DAT0 W
       R1=A
       P=     0
       LC(5)  =OY
       CD0EX
       A=R1
       DAT0=A W
       C=DAT1 A
       CD0EX
       A=R0
       DAT0=A W
       C=R2
       D0=C
       D1=D1+ 5
       RTNCC
****************************************************************
*
*
****************************************************************
* Y<>Z exchange the HP41 registers
       WORD 'Y<>Z'
       P=     0
       LC(5)  =OY            put Y-address into field A of register C low order 5 nibbles C(A)
       CD0EX                 exchange data pointer address D0 with C(A)
       R1=C                  save D0 into R1
       C=DAT0 W              C = value of Y from its address in C(A)
       D0=D0+ 16             D0 show now towards Z
       A=DAT0 W              put value of Z (from address D0) into A
       DAT0=C W              Z = value of Y
       D0=D0- 16             D0 -> Y
       DAT0=A W              Y = value of Z
       C=R1
       D0=C                  restore D0
       RTNCC
****************************************************************
*
*
****************************************************************
* Y<>T exchange the HP41 registers tested 17 July 2024
       WORD 'Y<>T'
       P=     0
       LC(5)  =OY
       CD0EX
       R1=C
       C=DAT0 W
       D0=D0+ 16
       D0=D0+ 16
       A=DAT0 W
       DAT0=C W
       D0=D0- 16
       D0=D0- 16
       DAT0=A W
       C=R1
       D0=C
       RTNCC
****************************************************************
*
*
****************************************************************
* Y<>L exchange the HP41 registers tested 17 July 2024
       WORD 'Y<>L'
       P=     0
       LC(5)  =OY
       CD0EX
       R1=C
       C=DAT0 W
       D0=D0- 16
       D0=D0- 16
       A=DAT0 W
       DAT0=C W
       D0=D0+ 16
       D0=D0+ 16
       DAT0=A W
       C=R1
       D0=C
       RTNCC
****************************************************************
*
*
****************************************************************
* Z<> exchange the value in the variable with the value in Z tested 17 July 2024
* use: FVAR1 Z<>
       WORD 'Z<>'
       P=     0
       LC(5)  =OZ
       CD0EX
       R2=C
       A=DAT0 W
       R0=A
       C=DAT1 A
       CD0EX
       A=DAT0 W
       R1=A
       P=     0
       LC(5)  =OZ
       CD0EX
       A=R1
       DAT0=A W
       C=DAT1 A
       CD0EX
       A=R0
       DAT0=A W
       C=R2
       D0=C
       D1=D1+ 5
       RTNCC
****************************************************************
*
*
****************************************************************
* Z<>T exchange the HP41 registers, tested July 11 2024
       WORD 'Z<>T'
       P=     0
       LC(5)  =OZ
       CD0EX
       R1=C
       C=DAT0 W
       D0=D0+ 16
       A=DAT0 W
       DAT0=C W
       D0=D0- 16
       DAT0=A W
       C=R1
       D0=C
       RTNCC
****************************************************************
*
*
****************************************************************
* Z<>L exchange the HP41 registers tested 17 July 2024
       WORD 'Z<>L'
       P=     0
       LC(5)  =OZ
       CD0EX
       R1=C
       C=DAT0 W
       D0=D0- 16
       D0=D0- 16
       D0=D0- 16
       A=DAT0 W
       DAT0=C W
       D0=D0+ 16
       D0=D0+ 16
       D0=D0+ 16
       DAT0=A W
       C=R1
       D0=C
       RTNCC
****************************************************************
*
*
****************************************************************
* T<> exchange the value in the variable with the value in T. tested 17 July 2024
*       use: FVAR1 T<>
       WORD 'T<>'
       P=     0
       LC(5)  =OT
       CD0EX
       R2=C
       A=DAT0 W
       R0=A
       C=DAT1 A
       CD0EX
       A=DAT0 W
       R1=A
       P=     0
       LC(5)  =OT
       CD0EX
       A=R1
       DAT0=A W
       C=DAT1 A
       CD0EX
       A=R0
       DAT0=A W
       C=R2
       D0=C
       D1=D1+ 5
       RTNCC
****************************************************************
*
*
****************************************************************
* T<>L exchange the HP41 registers. tested 17 July 2024
       WORD 'T<>L'
       P=     0
       LC(5)  =OT
       CD0EX
       R1=C
       C=DAT0 W
       D0=D0- 16
       D0=D0- 16
       D0=D0- 16
       D0=D0- 16
       A=DAT0 W
       DAT0=C W
       D0=D0+ 16
       D0=D0+ 16
       D0=D0+ 16
       D0=D0+ 16
       DAT0=A W
       C=R1
       D0=C
       RTNCC
****************************************************************
*
*
****************************************************************
* L<> exchange the value in the variable with the value in L tested 17 July 2024
*       use: FVAR1 L<>
       WORD 'L<>'
       P=     0
       LC(5)  =OL
       CD0EX
       R2=C
       A=DAT0 W
       R0=A
       C=DAT1 A
       CD0EX
       A=DAT0 W
       R1=A
       P=     0
       LC(5)  =OL
       CD0EX
       A=R1
       DAT0=A W
       C=DAT1 A
       CD0EX
       A=R0
       DAT0=A W
       C=R2
       D0=C
       D1=D1+ 5
       RTNCC
****************************************************************
*
*
****************************************************************
* <F> exchange the values of the 2 float variables
* tested 26 July 2024
* use: FVAR1 FVAR2 <F> 
       WORD '<F>'
       GOSBVL =SAVEFP        save pointers: CPU reg, D0, D1
       C=DAT1 A              copy data at 1st address in D1 into C(A)
       CD0EX                 exchange C(A) with D0
       A=DAT0 W              value into A
       R0=A                  R0 = Value1
       D1=D1+ 5
       C=DAT1 A              copy data at 2nd address in D1 into C(A)
       CD0EX
       A=DAT0 W
       R1=A                  R1 = value2
       A=R0
       DAT0=A W              Store value1 at addr2
       D1=D1- 5
       C=DAT1 A
       CD0EX
       A=R1
       DAT0=A W              Store value2 at addr1
       GOSBVL =GETFP         restore pointers: CPU reg, D0, D1
       D1=D1+ 10             return nothing on data stack
       RTNCC
****************************************************************
*
*
****************************************************************
* XYZ>ZXY Stack manipulation = "X<>Y then X<>Z"
* tested 6 Sept 2024
       WORD 'XYZ>ZXY'
* X<>Y
       GOSBVL =X<>Y
* X<>Z
       P=     0
       LC(5)  =OX            put X-address into field A of register C low order 5 nibbles
       CD0EX                 put data pointer D0 into C(A)
       R1=C                  save D0 into R1
       C=DAT0 W              C = value of X (which is in D0)
       D0=D0+ 16             D0 has now Y addr
       D0=D0+ 16             D0 has now Z addr
       A=DAT0 W              put value of Z into A via addr in D0
       DAT0=C W              Z = value of X
       D0=D0- 16
       D0=D0- 16             D0 -> X
       DAT0=A W              X = value of Z
       C=R1
       D0=C                  restore D0
       RTNCC
****************************************************************
*
*
****************************************************************
* XYZ>YZX Stack manipulation = "X<>Y then Y<>Z"
* tested 6 Sept 2024
****************************************************************
       WORD 'XYZ>YZX'
* X<>Y
       GOSBVL =X<>Y
* then Y<>Z
       P=     0
       LC(5)  =OY            put Y-address into field A of register C low order 5 nibbles C(A)
       CD0EX                 exchange data pointer address D0 with C(A)
       R1=C                  save D0 into R1
       C=DAT0 W              C = value of Y from its address in C(A)
       D0=D0+ 16             D0 show now towards Z
       A=DAT0 W              put value of Z (from address D0) into A
       DAT0=C W              Z = value of Y
       D0=D0- 16             D0 -> Y
       DAT0=A W              Y = value of Z
       C=R1
       D0=C                  restore D0
       RTNCC
****************************************************************
*
*
****************************************************************
* ST- substract X value in the reg address, no lastX
* use> FVARNAME1 ST- will substract the X value within FVARNAME1
* tested 18 Sept 2024
       WORD 'ST-'
       GOSBVL =CHS           change sign of X for later calc
       GOSBVL =SAVEFP        save pointers: CPU reg, D0, D1
       C=DAT1 A              copy data at address in D1 into C(A) = field A of reg C D1 is the data pointer
       CD0EX                 exchange C(A) with D0 (the instruction pointer) for now reading the values
       A=DAT0 W              copy data at address in D0 (in C(A)) into W in A
       R0=A                  R0: value of data at address for later
       P=     0
       LC(5)  =OX            load of X register addr into C(A)
       CD0EX                 exchange C(A) with D0 (the instruction pointer)
       A=DAT0 W              copy data of X into A
       C=A    W              (-XValue) into (C)
       A=R0                  (RegValue) into (A)
       GOSBVL =SPLTAC        (A) in (A,B) and (C) in (C,D)
       GOSBVL =AD2-15        (A,B) + (C,D) and result in (A,B) = RegVal -X
       GOSBVL =uRES12        (A,B) into (C)
       A=C    W              put C into A
       C=DAT1 A              copy data at address in D1 into C(A)
       CD0EX                 exchange C(A) with D0 (the instruction pointer)
       DAT0=A W              Write value (OrgRegVal -X) to reg back
       GOSBVL =GETFP         restore pointers: CPU reg, D0, D1
       GOSBVL =CHS           change back from -X to X
       D1=D1+ 5              return nothing on data stack
       RTNCC
****************************************************************
*
*
****************************************************************
* ST+ add X value in the reg address, no lastX
* use> FVARNAME1 ST+ will add the X value within FVARNAME1
* released 23 july 2024
       WORD 'ST+'
       GOSBVL =SAVEFP
       P=     0
       LC(5)  =OX
       CD0EX
       A=DAT0 W              A=X
       R0=A
       C=DAT1 A              Field A (=address) in D1 into C(A)
       R1=C                  R1=D1
       CD0EX                 Put it into D0
       A=DAT0 W              A=RegValue
       B=A    W
       C=B    W              C=X
       A=R0                  A=RegValue
       SETDEC
       GOSBVL =AD2-12
       SETHEX
       GOSBVL =uRESD1
       A=C    W
       C=R1
       CD0EX
       DAT0=A W
       GOSBVL =GETFP
       D1=D1+ 5
       RTNCC
****************************************************************
*
*
****************************************************************
* ST* multiply X value into the reg address, no lastX
* use: FVARNAME1 ST* will multiply FVARNAME1 by X
* released 24 july 2024
       WORD 'ST*'
       GOSBVL =SAVEFP
       P=     0
       LC(5)  =OX
       CD0EX
       A=DAT0 W              A=X
       R0=A
       C=DAT1 A              Field A (=address) in D1 into C(A)
       R1=C                  R1=D1
       CD0EX                 Put it into D0
       A=DAT0 W              A=RegValue
       B=A    W
       C=B    W              C=X
       A=R0                  A=RegValue
       SETDEC
       GOSBVL =MP2-12
       SETHEX
       GOSBVL =uRESD1
       A=C    W
       C=R1
       CD0EX
       DAT0=A W
       GOSBVL =GETFP         restore pointers: CPU reg, D0, D1
       D1=D1+ 5
       RTNCC
****************************************************************
*
*
****************************************************************
* ST/ divise the value in reg address by X, no lastX
* use: FVARNAME1 ST/ will divise FVARNAME1 by X
* released 24 july 2024
       WORD 'ST/'
       GOSBVL =SAVEFP
       P=     0
       LC(5)  =OX
       CD0EX
       A=DAT0 W              A=X
       R0=A
       C=DAT1 A              Field A (=address) in D1 into C(A)
       R1=C                  R1=D1
       CD0EX                 Put it into D0
       A=DAT0 W              A=RegValue
       C=R0                  C=X
       SETDEC
       GOSBVL =DV2-12
       SETHEX
       GOSBVL =uRESD1
       A=C    W
       C=R1
       CD0EX
       DAT0=A W
       GOSBVL =GETFP          restore pointers: CPU reg, D0, D1
       D1=D1+ 5
       RTNCC
****************************************************************
*
*
****************************************************************
* ST^ exponent the value in reg address by X, no lastX
* test
       WORD 'ST^'
       GOSBVL =SAVEFP
       P=     0
       LC(5)  =OX
       CD0EX
       A=DAT0 W              A=X
       R0=A
       C=DAT1 A              Field A (=address) in D1 into C(A)
       R1=C                  R1=D1
       CD0EX                 Put it into D0
       A=DAT0 W              A=RegValue
       C=R0                  C=X
       SETDEC
       GOSBVL =YX2-12
       SETHEX
       GOSBVL =uRESD1
       A=C    W
       C=R1
       CD0EX
       DAT0=A W
       GOSBVL =GETFP         restore pointers: CPU reg, D0, D1
       D1=D1+ 5
       RTNCC
****************************************************************
*
*
****************************************************************
* RC- upload value from register then substract it to X  
* tested 22 July 2024
       WORD 'RC-'
       GOSBVL =SAVEFP        save pointers: CPU reg, D0, D1
       C=DAT1 A
       CD0EX
       A=DAT0 W
       R1=A                  RegVal into R1
       P=     0
       LC(5)  =OX
       CD0EX
       A=DAT0 W
       D0=D0- 16
       DAT0=A W              X into L
       GOSBVL =CHS           -X
       D0=(5)  =OX
       A=DAT0 W
       C=A    W              -X into C
       A=R1                  RegVal into A
       GOSBVL =AD2-12        -X+RegVal
       GOSBVL =uRES12
       A=C    W              A = -Result
       P=     0
       LC(5)  =OX
       CD0EX
       DAT0=A W              -Result into X
       GOSBVL =GETFP         restore pointers: CPU reg, D0, D1
       GOSBVL =CHS           Result now in X
       D1=D1+ 5
       RTNCC
****************************************************************
*
*
****************************************************************
* RC+ upload value from register then add it to X 
* tested 23 july 2024
       WORD 'RC+'
       GOSBVL =SAVEFP
       C=DAT1 A
       CD0EX
       A=DAT0 W
       R0=A                  RegVal into R0
       P=     0
       LC(5)  =OX
       CD0EX
       A=DAT0 W              A = X
       D0=D0- 16
       DAT0=A W              X into L
       B=A    W
       C=B    W
       A=R0                  X in C, RegVal in A.. C=R0 better?
       GOSBVL =SPLTAC
       SETDEC
       GOSBVL =AD2-15
       SETHEX
       GOSBVL =uRESD1
       A=C    W              A = Result
       D0=(5) =OX
       DAT0=A W              Store result into X
       GOSBVL =GETFP          restore pointers: CPU reg, D0, D1
       D1=D1+ 5
       RTNCC
****************************************************************
*
*
****************************************************************
* RC/ upload value from register then divide X by it 
* tested 23 july 2024
       WORD 'RC/'
       GOSBVL =SAVEFP
       C=DAT1 A
       CD0EX
       A=DAT0 W
       R0=A                  RegVal into R0
       P=     0
       LC(5)  =OX
       CD0EX
       A=DAT0 W
       D0=D0- 16
       DAT0=A W              X into L, A=X
       C=R0
       GOSBVL =SPLTAC
       SETDEC
       GOSBVL =DV2-15
       SETHEX
       GOSBVL =uRESD1
       A=C    W              A = Result
       D0=(5) =OX
       DAT0=A W              Result into X
       GOSBVL =GETFP
       D1=D1+ 5
       RTNCC
****************************************************************
*
*
****************************************************************
* RC* upload value from register then multiply X with it
* tested 23 July 2024
       WORD 'RC*'
       GOSBVL =SAVEFP
       C=DAT1 A
       CD0EX
       A=DAT0 W
       R0=A                  RegVal into R0
       P=     0
       LC(5)  =OX
       CD0EX
       A=DAT0 W
       D0=D0- 16
       DAT0=A W              X into L, A=X
       B=A    W
       C=B    W 
       A=R0                  A=Regval, C=X
       GOSBVL =SPLTAC
       SETDEC
       GOSBVL =MP2-15
       SETHEX
       GOSBVL =uRESD1
       A=C    W              A = Result
       D0=(5) =OX
       DAT0=A W              Result into X
       GOSBVL =GETFP
       D1=D1+ 5
       RTNCC
****************************************************************
*
*
****************************************************************
* RC^ upload value from register then exponent X by it 
* test
       WORD 'RC^'
       GOSBVL =SAVEFP
       C=DAT1 A
       CD0EX
       A=DAT0 W
       R0=A                  RegVal into R0
       P=     0
       LC(5)  =OX
       CD0EX
       A=DAT0 W
       D0=D0- 16
       DAT0=A W              X into L, A=X
       C=R0
       SETDEC
       GOSBVL =YX2-12
       SETHEX
       GOSBVL =uRESD1
       A=C    W              A = Result
       D0=(5) =OX
       DAT0=A W              Result into X
       GOSBVL =GETFP
       D1=D1+ 5
       RTNCC
****************************************************************
*
*
****************************************************************
* FVCHS change sign of value in the float var address
* use: FVARNAME1 FVCHS will minus(value) within FVARNAME1 which is a FVARIABLE
* tested 24 July 2024
       WORD 'FVCHS'
       GOSBVL =SAVEFP
       C=DAT1 A              copy data at address in D1 into C(A)
       CD0EX
       A=DAT0 W              copy data at address in D0 (in C(A)) into W in A
       SETDEC
       A=-A-1 S
       SETHEX
       DAT0=A W
       CD0EX                 exchange C(A) with D0
       GOSBVL =GETFP
       D1=D1+ 5              return nothing on data stack
       RTNCC
****************************************************************
*
*
****************************************************************
* DEG-RAD : Deg to Rad conversion (D-R in HP41)
* Result in X is X(old) * (PI/2) / (2* 45)
* X(old) go into LastX
* tested 02 Aug 2024
       WORD 'DEG-RAD'            
       GOSBVL =NUMST         GET X INTO (A,B), uMODES;SAVEFP;GETX+L
       GOSBVL =PI/2
       SETDEC
       GOSBVL =MP2-15        Resut in A,B
       SETHEX
* create 90 in (C,D)
       C=0    W
       D=C    W
       P=     0
       C=C+1  P              Exponent 10**1
       P=     14
       D=D+1  P              
       D=D+1  P
       D=D+D  P
       D=D+D  P
       D=D+1  P              9 in D mantissa
*
       SETDEC
       GOSBVL =DV2-15        Result in A,B
       SETHEX
       GOSBVL =PUTABX
       RTNCC
****************************************************************
*
*
****************************************************************
* RAD-DEG : Rad to Deg conversion (R-D in HP41)
* Result in X is X(old) * (2* 45) / (PI/2)
* X(old) go into LastX
* tested 2nd Aug 2024
       WORD 'RAD-DEG'
       GOSBVL =NUMST         GET X INTO (A,B), uMODES;SAVEFP;GETX+L
* create 90 in (C,D)
       C=0    W
       D=C    W
       P=     0
       C=C+1  P              Exponent 10**1
       P=     14
       D=D+1  P
       D=D+1  P
       D=D+D  P
       D=D+D  P
       D=D+1  P              9 in D mantissa
*
       SETDEC
       GOSBVL =MP2-15        Resut in A,B
       SETHEX
       GOSBVL =PI/2
       SETDEC
       GOSBVL =DV2-15        Result in A,B
       SETHEX
       GOSBVL =PUTABX
       RTNCC
****************************************************************
*
*
****************************************************************
* %CH : calculate [(x —-y) 100] / y, see %CH HP41 manual page 84
* tested 02 Aug 2024
       WORD '%CH'
       GOSBVL =SAVEFP
       P=     0
       LC(5)  =OX
       CD0EX
       A=DAT0 W
       D0=D0- 16
       DAT0=A W              X into L, A=X
       R0=A
       P=     0
       LC(5)  =OY
       CD0EX
       A=DAT0 W              A = Y
       SETDEC
       A=-A-1 S              A = -Y
       SETHEX
       B=A    W
       C=B    W 
       A=R0                  A=X, C=-Y
       SETDEC
       GOSBVL =AD2-12        (X-Y) in (A,B)
       SETHEX
       C=0    W
       D=C    W
       P=     0
       C=C+1  P              
       C=C+1  P              Exponent 10**2
       P=     14
       D=D+1  P              1 in D mantissa.. = 100 in (C,D)
       SETDEC
       GOSBVL =MP2-15        Resut in A,B
       SETHEX
       GOSBVL =EXAB1         [(x —-y) 100] into (R0,R1)
       P=     0
       LC(5)  =OY
       CD0EX
       A=DAT0 W              A = Y
       GOSBVL =SPLTAX         (A,B) = Y
       C=B    W
       D=C    W
       C=A    W              (C,D) = Y
       GOSBVL =EXAB1         (A,B) now = [(x —-y) 100]
       SETDEC
       GOSBVL =DV2-15        (A,B) = [(x —-y) 100] / Y
       GOSBVL =uRESD1
       SETHEX
       A=C    W              A = Result
       D0=(5) =OX
       DAT0=A W              Result into X
       GOSBVL =GETFP
       RTNCC
****************************************************************
*
*
****************************************************************
* %OF : calculate (X*Y)/100, see % in HP41 manual page 83, =pdf 89
* use: 500.0 94.0 %OF  result 470.00 in X, 94 in LASTX
* tested 02 Aug 2024
       WORD '%OF'
       GOSBVL =SAVEFP
       P=     0
       LC(5)  =OX
       CD0EX
       A=DAT0 W
       D0=D0- 16
       DAT0=A W              X into L, A=X
       R0=A
       P=     0
       LC(5)  =OY
       CD0EX
       A=DAT0 W              A = Y
       B=A    W
       C=B    W 
       A=R0                  A=X, C=Y
       SETDEC
       GOSBVL =MP2-12         (X*Y) in (A,B)
       SETHEX
* reduce exponent nb by 2 for divide by 100? not tested..
       C=0    W
       D=C    W
       P=     0
       C=C+1  P              
       C=C+1  P              Exponent 10**2
       P=     14
       D=D+1  P              1 in D mantissa.. = 100 in (C,D)
       SETDEC
       GOSBVL =DV2-15        Result in A,B
       GOSBVL =uRESD1
       SETHEX
       A=C    W              A = Result
       D0=(5) =OX
       DAT0=A W              Result into X
       GOSBVL =GETFP
       RTNCC
****************************************************************
*
*
****************************************************************
* XSIGN : put +1.00 (X>=0) or -1.00 into X. Put old X into LASTX
* tested 2 Aug 2024
       WORD 'XSIGN'
       GOSBVL =SAVEFP        take the WRN: message away
       LC(5)  =OX
       CD0EX
       A=DAT0 W              X into A
       D0=D0- 16
       DAT0=A W              X into L
       D0=D0+ 16             point again to X
       A=0    A
       A=0    M
       P=     14
       A=A+1  P              Create "1" with the same sign than X
       DAT0=A W
       GOSBVL =GETFP         take the WRN: message away
       RTNCC
****************************************************************
*
*
****************************************************************
* PI : put PI into X in the stack. uplift the float stack. lastx not changed (like HP41)
* tested 23Aug2024
       WORD 'PI'
       GOSBVL =SAVEFP
       C=0    S
       P=     0
       LCHEX  314159265359000
       R0=C                  R0 = Result
       GOSBVL =STKLFT
       A=R0
       D0=(5) =OX
       DAT0=A W              Result into X
       GOSBVL =GETFP
       RTNCC
****************************************************************
*
*
****************************************************************
* create HP41 like tone function with input 0 (low)..9 (high)
* input in the integer stack (in HP41 it is as a line command TONE x)
* ( n -- ) TONE
* 0 .. 394 Hz  >> Value 394 + (43.777 * N) 
* 1 .. 437.8
* ..
* 8 .. 744.2
* 9 .. 788 HZ
* length 0,28s
* however inputs higher than 9 will be accepted
* negative values -8 (example) will be taken as 8
* tested Aug22 2024
* use  5 TONE in Forth prompt
       WORD 'TONE'
       GOSBVL =ABS           for positive whatever input was
       GOSBVL =SAVEFP
       A=DAT1 A
       GOSBVL =HDFLT         change A(A) to float A(W) 12 digits for further calc. exit with DEC mode
       C=0    S
       P=     0
       LCHEX  437777777777001 
       GOSBVL =MP2-12        result into (A,B)
       GOSBVL =uRESD1        result into C
       R0=C
       C=0    S              S instead of W for less size?
       P=     0
       LCHEX  394000000000002
       A=R0
       GOSBVL =AD2-12        result into (A,B)
       GOSBVL =uRESD1        result into C as 12 digit
       R0=C                  R0 Hz 
       C=0    W
       P=     0
       LCHEX  280000000000999 C duration
       SETDEC
       A=R0
       GOSBVL =BP
       GOSBVL =GETFP
       D1=D1+ 5              take the value out of the stack
       RTNCC
****************************************************************
*
*
****************************************************************
* BEEP41  the HP41 beep sound on HP71B
* https://www.hpcalc.org/details/7826 
* .. The 41's BEEP is TONE 7, TONE 5, TONE 8, TONE 7
* According to the Wickes book on synthetic programming the frequencies are as follows:
* TONE 7 = 629 Hz
* TONE 5 = 394 Hz
* TONE 8 = 788 Hz
* TONE 7 = 629 Hz
* The book also says that the duration of the standard tones is 0,28 seconds.
* tested Aug4 2024
       WORD 'BEEP41'
       GOSBVL =SAVEFP
       C=0    W
* Tone 7
       LCHEX  629000000000002
       A=C    W
       R0=C
       LCHEX  280000000000999
       R1=C
       GOSBVL =BP
* Tone 5 
       LCHEX  394000000000002
       A=C    W
       C=R1
       GOSBVL =BP
* Tone 8
       LCHEX  788000000000002
       A=C    W
       C=R1
       GOSBVL =BP
* Tone 7
       A=R0
       C=R1
       GOSBVL =BP
       GOSBVL =GETFP
       RTNCC
****************************************************************
*
*
****************************************************************
* X<0?  check if the value in X is <0 then put 0 (false) 
*   or -1 (true) into the integer stack
*   similar to HP41; however use of an integer stack instead of
*   program counter jump or not (like the Forth word X=0?)
*   no float stack change
*   tested 21Aug2024
       WORD 'X<0?'
       ST=1   0
       GOSBVL =CMPST
       P=     1
       GOTO   CMP0
* X<=0?
       WORD 'X<=0?'
       ST=1   0
       GOSBVL =CMPST
       P=     3
       GOTO   CMP0
* X#0?
       WORD 'X#0?'
       ST=1   0
       GOSBVL =CMPST
       P=     5
       GOTO   CMP0
* X>0?
       WORD 'X>0?'
       ST=1   0
       GOSBVL =CMPST
       P=     4
CMP0   GOVLNG =XXYY
****************************************************************
*
*
****************************************************************
* R-P : Rad to Polar conversion
* see HP41 manual page 92
* 1.0 2.0 R-P gives 2.2361 (SQRT(5)) in X and 26.56° or 0.4636 Rad in Y
* change the output if use of the words RADIANS or DEGREES
* tested 3 sept 2024.
* WRN: coming; reason unknown; however result ok
****************************************************************
       WORD 'R-P'
       GOSBVL =NUMST         GET X INTO (A,B), uMODES;SAVEFP;GETX+L
       GOSBVL =uRES12        C = (A,B)
       A=C    W
       R0=A                  X in A and R0
       SETDEC
       GOSBVL =MP2-12
       GOSBVL =uRES12        C = (A,B)
       A=C    W
       R2=A                  X**2 in A and R2
       P=     0
       LC(5)  =OY
       CD0EX
       A=DAT0 W
       R1=A                  Y in A and R1
       C=R0                  X in C
       SETDEC
       GOSBVL =DV2-12
       GOSBVL =ATAN15
       GOSBVL =uRES12        C = (A,B)
       A=C    W
       P=     0
       LC(5)  =OY
       CD0EX
       DAT0=A W              copy data of A into Y
       A=R1
       C=A    W
       SETDEC
       GOSBVL =MP2-12
       GOSBVL =uRES12        C = (A,B)
       A=C    W              Y**2 in A
       C=R2                  X**2 in C
       SETDEC
       GOSBVL =AD2-12
       GOSBVL =SQR15
       GOSBVL =PUTABX
       RTNCC
****************************************************************
*
*
****************************************************************
* P-R : Polar to Rad conversion
* see HP41 manual page 92
* use..
* 26.56° or 0.4636 Rad in Y   then 
*  2.2361 (SQRT(5)) in X    P-R
*  gives 1.0 in Y and 2.0 in X
* tested 03 Sept 2024
****************************************************************
       WORD 'P-R'
       GOSBVL =NUMST         GET X INTO (A,B), uMODES;SAVEFP;GETX+L
       P=     0
       LC(5)  =OY
       CD0EX
       A=DAT0 W
       R2=A                  Angle in R2
       SETDEC
       GOSBVL =SIN12
       GOSBVL =uRES12        uRES12 modify R3 therefore avoid R3
       A=C    W
       P=     0
       LC(5)  =OX
       CD0EX                 exchange data pointer address D0 with C(A)
       C=DAT0 W              C = value of X from its address in C(A)
       SETDEC
       GOSBVL =MP2-12        Modulus*sin(angle) in (A,B)
       GOSBVL =uRES12
       A=C    W
       P=     0
       LC(5)  =OY
       CD0EX
       DAT0=A W              copy data of A (modulus * sin(angle)) into Y
       A=R2
       GOSBVL =COS12         cos(angle) in (A,B)
       GOSBVL =uRES12
       A=C    W
       P=     0
       LC(5)  =OX
       CD0EX                 exchange data pointer address D0 with C(A)
       C=DAT0 W              C = value of X from its address in C(A)
       SETDEC
       GOSBVL =MP2-12        Modulus*cos(angle) in (A,B)
       GOSBVL =PUTABX        Modulus*cos(angle) into X
       RTNCC
****************************************************************
*
       END
